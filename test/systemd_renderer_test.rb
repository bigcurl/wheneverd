# frozen_string_literal: true

require_relative "test_helper"

module SystemdRendererTestHelpers
  def render_units(entries, identifier: "demo")
    Wheneverd::Systemd::Renderer.render(Wheneverd::Schedule.new(entries: entries),
                                        identifier: identifier)
  end

  def timer_for(entry, identifier: "demo")
    render_units([entry], identifier: identifier).find { |u| u.kind == :timer }
  end

  def service_for(entry, identifier: "demo")
    render_units([entry], identifier: identifier).find { |u| u.kind == :service }
  end

  def interval_entry(seconds:, command:)
    Wheneverd::Entry.new(
      trigger: Wheneverd::Trigger::Interval.new(seconds: seconds),
      jobs: [Wheneverd::Job::Command.new(command: command)]
    )
  end

  def boot_entry(seconds:, command:)
    Wheneverd::Entry.new(
      trigger: Wheneverd::Trigger::Boot.new(seconds: seconds),
      jobs: [Wheneverd::Job::Command.new(command: command)]
    )
  end

  def calendar_entry(spec:, command:)
    Wheneverd::Entry.new(
      trigger: Wheneverd::Trigger::Calendar.new(on_calendar: [spec]),
      jobs: [Wheneverd::Job::Command.new(command: command)]
    )
  end

  def marker
    "# Generated by wheneverd (wheneverd) #{Wheneverd::VERSION}; do not edit."
  end
end

class SystemdRendererIntervalTest < Minitest::Test
  include SystemdRendererTestHelpers

  def test_interval_timer_contains_required_fields
    timer = timer_for(interval_entry(seconds: 60, command: "echo hello"))
    refute_nil timer
    assert_includes timer.contents, marker
    assert_includes timer.contents, "OnActiveSec=60"
    assert_includes timer.contents, "OnUnitActiveSec=60"
    assert_includes timer.contents, "Persistent=true"
    assert_includes timer.contents, "WantedBy=timers.target"
  end

  def test_interval_service_contains_execstart
    service = service_for(interval_entry(seconds: 60, command: "echo hello"))
    refute_nil service
    assert_includes service.contents, marker
    assert_includes service.contents, "Type=oneshot"
    assert_includes service.contents, "ExecStart=echo hello"
  end
end

class SystemdRendererCalendarTest < Minitest::Test
  include SystemdRendererTestHelpers

  def test_calendar_hour_translates_to_hourly
    timer = timer_for(calendar_entry(spec: "hour", command: "echo hourly"))
    assert_includes timer.contents, "OnCalendar=hourly"
  end

  def test_calendar_day_at_translates_to_date_time
    timer = timer_for(calendar_entry(spec: "day@4:30 am", command: "echo four_thirty"))
    assert_includes timer.contents, "OnCalendar=*-*-* 04:30:00"
  end

  def test_calendar_sunday_at_translates_to_day_of_week
    timer = timer_for(calendar_entry(spec: "sunday@12pm", command: "echo weekly"))
    assert_includes timer.contents, "OnCalendar=Sun *-*-* 12:00:00"
  end

  def test_cron_example_translates_to_expected_on_calendar
    timer = timer_for(calendar_entry(spec: "cron:0 0 27-31 * *", command: "echo raw_cron"))
    assert_includes timer.contents, "OnCalendar=*-*-27..31 00:00:00"
  end

  def test_cron_with_day_of_month_and_day_of_week_expands_to_multiple_on_calendar_lines
    timer = timer_for(calendar_entry(spec: "cron:0 0 1 * Mon", command: "echo raw_cron"))
    assert_includes timer.contents, "OnCalendar=Mon *-*-* 00:00:00"
    assert_includes timer.contents, "OnCalendar=*-*-1 00:00:00"
  end
end

class SystemdRendererNamingTest < Minitest::Test
  include SystemdRendererTestHelpers

  def test_naming_is_deterministic
    entries = entries_for_determinism
    units1 = render_units(entries, identifier: "my-app")
    units2 = render_units(entries, identifier: "my-app")
    assert_equal units1.map(&:path_basename), units2.map(&:path_basename)
    assert_equal units1.map(&:contents), units2.map(&:contents)
  end

  def test_units_keep_names_across_entry_reordering
    entry_a = interval_entry(seconds: 60, command: "echo a")
    entry_b = boot_entry(seconds: 60, command: "echo b")

    units1 = render_units([entry_a, entry_b], identifier: "my-app").sort_by(&:path_basename)
    units2 = render_units([entry_b, entry_a], identifier: "my-app").sort_by(&:path_basename)

    assert_equal units1.map(&:path_basename), units2.map(&:path_basename)
    assert_equal units1.map(&:contents), units2.map(&:contents)
  end

  def test_duplicate_jobs_get_disambiguated_unit_ids
    timer_basenames = timer_basenames_for_entries([duplicate_job_entry], identifier: "my-app")
    assert_equal 2, timer_basenames.length
    assert_disambiguated_timer_basenames(timer_basenames)
  end

  private

  def entries_for_determinism
    [
      Wheneverd::Entry.new(trigger: Wheneverd::Trigger::Interval.new(seconds: 60), jobs: jobs_a_b),
      boot_entry(seconds: 60, command: "echo c")
    ]
  end

  def jobs_a_b
    [
      Wheneverd::Job::Command.new(command: "echo a"),
      Wheneverd::Job::Command.new(command: "echo b")
    ]
  end

  def duplicate_job_entry
    Wheneverd::Entry.new(
      trigger: Wheneverd::Trigger::Interval.new(seconds: 60),
      jobs: [
        Wheneverd::Job::Command.new(command: "echo a"),
        Wheneverd::Job::Command.new(command: "echo a")
      ]
    )
  end

  def timer_basenames_for_entries(entries, identifier:)
    render_units(entries, identifier: identifier)
      .map(&:path_basename)
      .select { |b| b.end_with?(".timer") }
  end

  def assert_disambiguated_timer_basenames(timer_basenames)
    assert(timer_basenames.any? { |b| /\Awheneverd-my-app-[0-9a-f]{12}-1\.timer\z/.match?(b) })
    assert(timer_basenames.any? { |b| /\Awheneverd-my-app-[0-9a-f]{12}-2\.timer\z/.match?(b) })
  end
end

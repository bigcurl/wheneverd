# frozen_string_literal: true

module Wheneverd
  module Systemd
    # A rendered systemd unit (service or timer).
    #
    # @!attribute [r] path_basename
    #   @return [String] file name, e.g. `"wheneverd-myapp-0123abcd4567.timer"`
    # @!attribute [r] kind
    #   @return [Symbol] `:service` or `:timer`
    # @!attribute [r] contents
    #   @return [String] unit file contents
    Unit = Struct.new(:path_basename, :kind, :contents, keyword_init: true)

    # Renders a {Wheneverd::Schedule} into systemd units.
    #
    # Each job in each entry becomes a `*.service` plus matching `*.timer`.
    #
    # Unit file names are generated as:
    #
    #   `wheneverd-<identifier>-<stable_id>.{service,timer}`
    #
    # The stable ID is derived from the job's trigger + command so reordering schedule blocks
    # does not rename units. If there are duplicate jobs with identical trigger + command, a stable
    # `-N` suffix is appended to avoid collisions.
    #
    # The identifier is sanitized for use in filenames (invalid characters become `-`).
    #
    # Uses {UnitContentBuilder} for generating unit file contents.
    class Renderer
      MARKER_PREFIX = "# Generated by wheneverd (wheneverd)"

      # Render a schedule to `systemd` units.
      #
      # @param schedule [Wheneverd::Schedule]
      # @param identifier [String] used to namespace unit file names
      # @return [Array<Unit>]
      def self.render(schedule, identifier:)
        validate_schedule(schedule)
        id = UnitPathUtils.sanitize_identifier(identifier)
        render_schedule(schedule, id)
      end

      def self.validate_schedule(schedule)
        return if schedule.is_a?(Wheneverd::Schedule)

        raise ArgumentError, "schedule must be a Wheneverd::Schedule (got #{schedule.class})"
      end
      private_class_method :validate_schedule

      def self.render_schedule(schedule, id)
        stable_ids = Wheneverd::Systemd::UnitNamer.stable_ids_for(schedule)
        stable_id_index = 0

        schedule.entries.flat_map do |entry|
          entry.jobs.flat_map do |job|
            stable_id = stable_ids.fetch(stable_id_index)
            stable_id_index += 1
            base = "wheneverd-#{id}-#{stable_id}"
            render_job(base, entry.trigger, job)
          end
        end
      end
      private_class_method :render_schedule

      def self.render_job(base, trigger, job)
        service = build_service_unit("#{base}.service", job)
        timer = build_timer_unit("#{base}.timer", trigger)
        [service, timer]
      end
      private_class_method :render_job

      def self.build_service_unit(path_basename, job)
        Unit.new(
          path_basename: path_basename,
          kind: :service,
          contents: UnitContentBuilder.service_contents(path_basename, job.command)
        )
      end
      private_class_method :build_service_unit

      def self.build_timer_unit(path_basename, trigger)
        timer_lines = UnitContentBuilder.timer_lines_for(trigger)
        Unit.new(
          path_basename: path_basename,
          kind: :timer,
          contents: UnitContentBuilder.timer_contents(path_basename, timer_lines)
        )
      end
      private_class_method :build_timer_unit
    end
  end
end

# frozen_string_literal: true

module Wheneverd
  module Systemd
    # A rendered systemd unit (service or timer).
    #
    # @!attribute [r] path_basename
    #   @return [String] file name, e.g. `"wheneverd-myapp-e0-j0.timer"`
    # @!attribute [r] kind
    #   @return [Symbol] `:service` or `:timer`
    # @!attribute [r] contents
    #   @return [String] unit file contents
    Unit = Struct.new(:path_basename, :kind, :contents, keyword_init: true)

    # Renders a {Wheneverd::Schedule} into systemd units.
    #
    # Each job in each entry becomes a `*.service` plus matching `*.timer`.
    #
    # Unit file names are generated as:
    #
    #   `wheneverd-<identifier>-e<entry_index>-j<job_index>.{service,timer}`
    #
    # The identifier is sanitized for use in filenames (invalid characters become `-`).
    class Renderer
      MARKER_PREFIX = "# Generated by wheneverd (wheneverd)"
      SERVICE_SECTION = ["[Service]", "Type=oneshot"].freeze
      TIMER_SUFFIX = ["Persistent=true", "", "[Install]", "WantedBy=timers.target", ""].freeze

      # Render a schedule to `systemd` units.
      #
      # @param schedule [Wheneverd::Schedule]
      # @param identifier [String] used to namespace unit file names
      # @return [Array<Unit>]
      def self.render(schedule, identifier:)
        validate_schedule(schedule)
        id = sanitize_identifier(identifier)
        render_schedule(schedule, id)
      end

      def self.validate_schedule(schedule)
        return if schedule.is_a?(Wheneverd::Schedule)

        raise ArgumentError, "schedule must be a Wheneverd::Schedule (got #{schedule.class})"
      end
      private_class_method :validate_schedule

      def self.render_schedule(schedule, id)
        schedule.entries.each_with_index.flat_map do |entry, entry_index|
          entry.jobs.each_with_index.flat_map do |job, job_index|
            base = "wheneverd-#{id}-e#{entry_index}-j#{job_index}"
            render_job(base, entry.trigger, job)
          end
        end
      end
      private_class_method :render_schedule

      def self.render_job(base, trigger, job)
        service = build_service_unit("#{base}.service", job)
        timer = build_timer_unit("#{base}.timer", trigger)
        [service, timer]
      end
      private_class_method :render_job

      def self.build_service_unit(path_basename, job)
        Unit.new(
          path_basename: path_basename,
          kind: :service,
          contents: service_contents(path_basename, job.command)
        )
      end
      private_class_method :build_service_unit

      def self.build_timer_unit(path_basename, trigger)
        timer_lines = timer_lines_for(trigger)

        Unit.new(
          path_basename: path_basename,
          kind: :timer,
          contents: timer_contents(path_basename, timer_lines)
        )
      end
      private_class_method :build_timer_unit

      def self.timer_lines_for(trigger)
        case trigger
        when Wheneverd::Trigger::Interval
          ["OnActiveSec=#{trigger.seconds}", "OnUnitActiveSec=#{trigger.seconds}"]
        when Wheneverd::Trigger::Boot
          ["OnBootSec=#{trigger.seconds}"]
        when Wheneverd::Trigger::Calendar then calendar_timer_lines(trigger)
        else raise ArgumentError, "Unsupported trigger type: #{trigger.class}"
        end
      end
      private_class_method :timer_lines_for

      def self.calendar_timer_lines(trigger)
        trigger.on_calendar.flat_map do |spec|
          CalendarSpec.to_on_calendar_values(spec).map { |value| "OnCalendar=#{value}" }
        end
      end
      private_class_method :calendar_timer_lines

      def self.service_contents(path_basename, command)
        ([
          marker,
          "[Unit]",
          "Description=wheneverd job #{path_basename}",
          ""
        ] + SERVICE_SECTION + ["ExecStart=#{command}", ""]).join("\n")
      end
      private_class_method :service_contents

      def self.timer_contents(path_basename, timer_lines)
        ([
          marker,
          "[Unit]",
          "Description=wheneverd timer #{path_basename}",
          "",
          "[Timer]"
        ] + timer_lines + TIMER_SUFFIX).join("\n")
      end
      private_class_method :timer_contents

      def self.marker
        "#{MARKER_PREFIX} #{Wheneverd::VERSION}; do not edit."
      end
      private_class_method :marker

      def self.sanitize_identifier(identifier)
        raw = identifier.to_s.strip
        raise InvalidIdentifierError, "identifier must not be empty" if raw.empty?

        sanitized = raw.gsub(/[^A-Za-z0-9_-]/, "-").gsub(/-+/, "-").gsub(/\A-|-+\z/, "")
        if sanitized.empty?
          raise InvalidIdentifierError,
                "identifier must include at least one alphanumeric character"
        end

        sanitized
      end
      private_class_method :sanitize_identifier
    end
  end
end
